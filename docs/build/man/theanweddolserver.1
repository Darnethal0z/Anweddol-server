.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "THEANWEDDOLSERVER" "1" "Jun 12, 2023" "" "The Anweddol server"
.SH NAME
theanweddolserver \- The Anweddol server beta-1.0.0
.sp
\fI\%made\-with\-python\fP
\fI\%build\-passing\fP
\fI\%license\fP
\fI\%reddit\fP

.sp
.ce
----

.ce 0
.sp
.SH GLOBAL OVERVIEW
.sp
Anweddol is a client/server system providing temporary, SSH\-controllable virtual machines to enhance anonymity online.
.sp
It’s usefulness comes when someone wants to use a fully functional computer while being exposed to less dangers by using it remotely on a dedicated server, and by destroying it after use.
.SH EFFECTIVE SCENARIO
.sp
\fIterminology :\fP
.INDENT 0.0
.IP \(bu 2
\fBContainer\fP : A temporary virtual machine hosted on a server that can be controlled from the client side.
.UNINDENT
.INDENT 0.0
.IP 1. 3
Alice wants to have access to a container. She will first send a request asking it to create a new container.
.IP 2. 3
The server will start a new container, administer it and send the SSH credentials to Alice for her to be able to securely interact with the container.
.IP 3. 3
Once that Alice is done, she will send another request with previously received container identification and credentials to the server.
.IP 4. 3
The server identifies the affiliated running container, and destroys it.
.UNINDENT
.SH CONTENTS
.SS Administration guide

.sp
.ce
----

.ce 0
.sp
.sp
Hello and welcome to the Anweddol server administration guide.
.sp
The following sections will explain how to administrate and configure the Anweddol server implementation in an optimal way.
.SS Installation

.sp
.ce
----

.ce 0
.sp
.sp
This section covers the prerequisites needed for the system before the Anweddol server installation.
.SS Prerequisites
.SS Libvirt
.sp
\fI\%Libvirt\fP is a toolkit to manage virtualization platforms that the server is using to manage container domains.
.SS Installation
.sp
Libvirt must be installed via your package manager :
.sp
Apt :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo apt\-get update
$ sudo apt\-get install python\-libvirt

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
DNF :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo dnf install python\-libvirt

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yum :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo yum install python\-libvirt

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE\fP : You can also install it from pip by executing :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ pip install libvirt\-python

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
But you need to install build dependencies manually, and this topic is not covered in this documentation.
.SS Setup
.sp
You need to modify the \fB/etc/libvirt/qemu.conf\fP file to give libvirt appropriate rights.
.sp
Edit the \fB/etc/libvirt/qemu.conf\fP file :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo nano /etc/libvirt/qemu.conf

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Find the \fBuser\fP and \fBgroup\fP directives. By default, both are set to \fBroot\fP :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[...] 
Some examples of valid values are:
#
user = \(dqqemu\(dq   # A user named \(dqqemu\(dq
user = \(dq+0\(dq     # Super user (uid=0)
user = \(dq100\(dq    # A user named \(dq100\(dq or a user with uid=100
#
#user = \(dqroot\(dq
The group for QEMU processes run by the system instance. It can be
specified in a similar way to user.
#group = \(dqroot\(dq
[...]

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Uncomment both lines and replace \fBroot\fP with \fBanweddol\fP and the group with \fBlibvirt\fP as shown below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[...] 
Some examples of valid values are:
#
user = \(dqqemu\(dq   # A user named \(dqqemu\(dq
user = \(dq+0\(dq     # Super user (uid=0)
user = \(dq100\(dq    # A user named \(dq100\(dq or a user with uid=100
#
user = \(dqanweddol\(dq
The group for QEMU processes run by the system instance. It can be
specified in a similar way to user.
group = \(dqlibvirt\(dq
[...]

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then restart the libvirtd daemon :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo systemctl restart libvirtd.service

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE\fP : At this point, the user \fBanweddol\fP is not created yet but it should not interfere with libvirt for now.
.sp
(source : \fI\%ostechnix\fP)
.SS Networking
.sp
For the containers to be able to communicate with the outside, the host system must have a bridge interface linking the main network interface to the container domain\(aqs interface.
.sp
It consists of a bridge interface with the main network interface set as a slave to the bridge :
the container domain\(aqs interface will connect to it on the runtime via TAP link.
.INDENT 0.0
.INDENT 3.5
If the server is using a WI\-FI interface as the main network interface, a more specific setup must be done before continuing (see the \fI\%debian documentation\fP for more).
.UNINDENT
.UNINDENT
.sp
Follow the steps below according to your system :
.SS Debian\-based systems
.sp
First, you need to stop the networking service :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ service network stop

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then you can create the \fBanwdlbr0\fP bridge interface, replacing \fBMASTER_INTERFACE_NAME\fP by your actual master interface name :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ brctl addbr anwdlbr0
$ brctl addif anwdlbr0 MASTER_INTERFACE_NAME

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Create persistent configuration files for your interfaces :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ printf \(dqiface MASTER_INTERFACE_NAME inet manual\(dq >> /etc/network/interfaces
$ printf \(dqiface anwdlbr0 inet dhcp\en\etbridge_ports MASTER_INTERFACE_NAME\(dq >> /etc/network/interfaces

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Enable the \fBanwdlbr0\fP interface, and restart the networking service :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ ifup anwdlbr0
$ service network start

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Redhat\-based systems
.sp
Disable NetworkManager :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo chkconfig NetworkManager off
$ sudo chkconfig network on
$ sudo service NetworkManager stop
$ sudo service network start

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Define the main network interface in networks\-script, replacing \fBMASTER_INTERFACE_NAME\fP by your actual master interface name  :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo printf \(dqDEVICE=MASTER_INTERFACE_NAME\enHWADDR=$(ifconfig MASTER_INTERFACE_NAME | grep \-o \-E ..:..:..:..:..:..)\enONBOOT=yes\enBRIDGE=anwdlbr0\enNM_CONTROLLED=no\(dq /etc/sysconfig/networks\-script/MASTER_INTERFACE_NAME

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Create the \fBanwdlbr0\fP bridge interface in networks\-script :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo printf \(dqDEVICE=anwdlbr0\enTYPE=Bridge\enBOOTPROTO=dhcp\enONBOOT=yes\enDELAY=0\enNM_CONTROLLED=no\(dq /etc/sysconfig/networks\-script/ifcfg\-anwdlbr0

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Add sysctl rules to enable packet forwarding :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo printf \(dqnet.bridge.bridge\-nf\-call\-ip6tables = 0\ennet.bridge.bridge\-nf\-call\-iptables = 0\ennet.bridge.bridge\-nf\-call\-arptables = 0\(dq >> /etc/sysctl.conf
$ sudo sysctl \-p /etc/sysctl.conf

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Add iptables rules to accept packet forwarding from bridged interfaces :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo printf \(dq\-I FORWARD \-m physdev \-\-physdev\-is\-bridged \-j ACCEPT\(dq /etc/sysconfig/anweddol\-iptables\-forward\-rules
$ sudo lokkit \-\-custom\-rules=ipv4:filter:/etc/sysconfig/anweddol\-iptables\-forward\-rules

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Restart the network service :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo service network restart

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Container ISO
.sp
Before using the server, you need to download a specific ISO image for the container domains in order to provide a functional service.
.sp
See the \fI\%Container ISO\fP section to learn more.
.SS Anweddol server installation
.sp
Install the Anweddol server with pip :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo pip install anwdlserver

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or by the sources :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ git clone https://github.com/the\-anweddol\-project/Anweddol\-server.git
$ cd Anweddol\-server
$ sudo pip install .

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The nessessary files and users will be created during the installation.
.SS Server usage

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
You need to follows the \fI\%Installation\fP section before continuing this tutorial.
.UNINDENT
.UNINDENT
.SS Start the server
.sp
First, you need the libvirtd daemon running :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo systemctl start libvirtd.service

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
(\fBoptional\fP) You may need to check if the server environment is correctly set up :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo anwdlserver start \-c

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If some error occured, check the \fI\%Troubleshooting\fP section to fix them.
.sp
Start the server via the CLI :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo anwdlserver start

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
(\fBoptional\fP) add the option \fB\-d\fP to enable direct execution (the server will run synchronously in the terminal)
.sp
Or via the systemd daemon :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo systemctl start anweddol\-server.service

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Stop the server
.sp
Stop the server via the CLI :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo anwdlserver stop

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or via the systemd daemon :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo systemctl stop anweddol\-server.service

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Access token

.sp
.ce
----

.ce 0
.sp
.sp
The Anweddol server implementation can restrict its utilization by using the \fBtools\fP \fI\%Access token feature\fP for client authentication.
.sp
An access token is a url\-safe 124 characters long used on the implementation to restrict access.
These tokens are stored in a SQLite database file on the system.
.sp
\fBNOTE\fP : There is one token for one client, since a client cannot store 2 tokens for one same server (see the \fI\%Client usage guide\fP to learn more).
.SS Prerequisites
.sp
This feature can be enabled or disabled.
Being disabled by default, you can enable it by changing the \fBenabled\fP field value for \fBTrue\fP :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[...]
  # List of allowed / denied IPs
  # Specify any IPs with \(aqany\(aq
  allowed_ip_list:
    \- any
  denied_ip_list: []

# \-\-\-
# Access token parameters
token_authentication:

  # Enable this feature or not
  # If this value is set to \(aqfalse\(aq, all parameters below will be ignored 
  enabled: True # <\-\-\-\-\- Here

[...]

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then restart the server.
.sp
\fBNOTE\fP : If this feature is enabled but no tokens are added, no clients will be able to use the server.
.SS Add / delete a token
.sp
To add a token to the database, execute :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ anwdlserver access\-tk \-a

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It will result with the created token and its entry ID on the standard output.
.sp
On the client\-side, you need to record this token in order to be able to authenticate.
See the \fI\%Client usage guide\fP to learn more.
.sp
\fBNOTE\fP : Since the access tokens are hashed in the database (see the technical specifications \fI\%Access token\fP section to learn more), there’s no way to see them again in plain text : Store this plain token somewhere safe in order to use it for further operations.
.sp
If you want to delete a token, execute :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ anwdlserver access\-tk \-r <entry_id>

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Enable / Disable a token
.sp
You have the possibility to enable or disable recorded tokens to temporarily disable its usage.
.sp
To disable a token, execute :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ anwdlserver access\-tk \-d <entry_id>

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE\fP : A created token is automatically enabled. Use the \fB\-\-disabled\fP option with the \fB\-a\fP parameter to disable it.
.sp
And to re\-enable it :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ anwdlserver access\-tk \-e <entry_id>

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Configuration file

.sp
.ce
----

.ce 0
.sp
.sp
The Anweddol server implementation is using a YAML file for configuration.
.sp
It is stored in \fB/etc/anweddol/config.yaml\fP after installation, read its header to learn about it.
.SS Container ISO

.sp
.ce
----

.ce 0
.sp
.sp
In order to provice a valid service, containers domains needs to run with a specific ISO image.
.SS Download the ISO image
.sp
This ISO image is actually a custom live Debian image that you can retrieve on the official mirror, you can download it from the CLI by executing :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo anwdlserver dl\-iso

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
By default, the downloaded ISO is stored on \fB/etc/anweddol/iso/anweddol_container.iso\fP, you can change this by editing the \fBcontainer_iso_path\fP field on the configuration file.
.sp
You can also specify a custom ISO mirror URL it with the \fB\-u\fP parameter
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo anwdlserver dl\-iso \-u https://example.com/url/of/the/mirror/root

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Learn more about the container ISO on the technical specifications \fI\%ISO management section\fP\&.
.SS Logging

.sp
.ce
----

.ce 0
.sp
.sp
The Anweddol server CLI uses the \fBlogging\fP python module to ensure viable logging feature.
.sp
Logs are stored in \fB/var/log/anweddol/runtime.txt\fP and are stored in this format :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\(dq ** %(asctime)s %(levelname)s : %(message)s\(dq

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here is a sample of logs generated during the development phase of the Anweddol server :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
 ** 2023\-05\-09 21:37:34,327 INFO : New client (ID : 12ca17b)
 ** 2023\-05\-09 21:37:34,371 INFO : [12ca17b] Received STAT request
 ** 2023\-05\-09 21:37:34,373 INFO : [12ca17b] Connection closed
 ** 2023\-05\-09 21:48:33,576 INFO : New client (ID : 12ca17b)
 ** 2023\-05\-09 21:48:33,621 INFO : [12ca17b] Received CREATE request
 ** 2023\-05\-09 21:48:33,621 INFO : [12ca17b] Container 41e7a14c\-d050\-40e1\-842c\-a9c86f903459 was created
 ** 2023\-05\-09 21:48:47,378 INFO : Connected (version 2.0, client OpenSSH_8.4p1)
 ** 2023\-05\-09 21:48:47,498 INFO : Authentication (password) successful!
 ** 2023\-05\-09 21:48:47,498 INFO : [12ca17b] Endpoint shell opened
 ** 2023\-05\-09 21:48:49,411 INFO : [12ca17b] Connection closed

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE\fP : Clients are represented by their IDs, here \(dq12ca17b\(dq : It is a way of programmatically identifying the client other than with his IP. It is the first 7 characters of the client\(aqs IP SHA256.
.SS Troubleshooting

.sp
.ce
----

.ce 0
.sp
.sp
Here is a list of non\-exhaustive potential problems that can be encountered while using the Anweddol server :
.SS […]\fBLibvirt : Permission denied\fP
.sp
\fIDescription\fP : The libvirt API failed to access or create a resource due to the lack of permissions.
.sp
\fISolution\fP :
.sp
See the Installation \fI\%setup section\fP to learn more.
.sp
If the problem persists, try to disable the SELinux enforce feature :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo setenforce 0

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Do not forget to re\-enable it when unused :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo setenforce 1

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Developer section

.sp
.ce
----

.ce 0
.sp
.sp
Hello and welcome to the Anweddol server developer documentation.
.sp
Here, you’ll find every informations and documentation about the server \fI\%python\fP API features.
.sp
\fBNOTE\fP : At the root of \fBanwdlserver\fP, there is the CLI source code : They are not meant to be used on an external program since it’s the server implementation’s code itself.
.SS Important note
.sp
The Anweddol server installation requires a specific setup before installation and usage in order to provide a functional service.
.sp
See the administration guide \fI\%Installation section\fP to learn more before getting started on the server API.
.SS Examples
.sp
See basic server stubs that can be used as examples.
.SS Basic server

.sp
.ce
----

.ce 0
.sp
.sp
Here is a simple server stub that can be used as a functional server :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from anwdlserver.core.server import ServerInterface

# Replace it with your own path
CONTAINER_ISO_PATH = \(dq/path/of/the/ISO/file.iso\(dq

# Create a new ServerInterface instance
server = ServerInterface(container_iso_path=CONTAINER_ISO_PATH)

# Print the message when the server is ready
@server.on_started
def notify_started(**kwargs):
	print(\(dqServer is started\(dq)

# Start the server
server.startServer()

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Handle a custom request verb

.sp
.ce
----

.ce 0
.sp
.sp
This stub shows how to implement a custom verb handling, here the server will respond \(dqPONG\(dq in parameters when a client sends a \(dqPING\(dq request :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from anwdlserver.core.server import (
	ServerInterface, 
	RESPONSE_MSG_OK
)

# Replace it with your own path
CONTAINER_ISO_PATH = \(dq/path/of/the/ISO/file.iso\(dq

# Sends \(aqPONG\(aq in response when a \(aqPING\(aq request is received
def handle_ping_request(**kwargs):
	client_instance = kwargs.get(\(dqclient_instance\(dq)

	print(\(dqReceived PING request\(dq)

	client_instance.sendResponse(True, RESPONSE_MSG_OK, data={\(dqanswer\(dq: \(dqPONG\(dq})

	# Not mandatory, but programatically correct
	client_instance.closeConnection()

# Create a new ServerInterface instance
server = ServerInterface(container_iso_path=CONTAINER_ISO_PATH)

# Print the message when the server is ready
@server.on_started
def notify_started(**kwargs):
	print(\(dqServer is started\(dq)
	
# Add the new \(aqPING\(aq request handler
server.setRequestHandler(\(dqPING\(dq, handle_ping_request)

# Start the server
server.startServer()

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Implement IP filtering

.sp
.ce
----

.ce 0
.sp
.sp
Here is a server stub that involves an IP filtering feature :
.INDENT 0.0
.INDENT 3.5
For performance reasons, it is recommended to implement an IP filtering feature with the \fBon_connection\fP callback since it is faster than a whole client instance.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from anwdlserver.core.server import ServerInterface

# Replace it with your own path / values
CONTAINER_ISO_PATH = \(dq/path/of/the/ISO/file.iso\(dq
DENIED_IP_ARRAY = [\(dq1.1.1.1\(dq, \(dq3.3.3.3\(dq, \(dq5.5.5.5\(dq]

# Create a new ServerInterface instance
server = ServerInterface(container_iso_path=CONTAINER_ISO_PATH)

# Print the message when the server is ready
@server.on_started
def notify_started(**kwargs):
	print(\(dqServer is started\(dq)

# IP filtering implementation
@server.on_connection
def handle_connection(**kwargs):
	client_socket = kwargs.get(\(dqclient_socket\(dq)
	client_ip = client_socket.getpeername()[0]

	if client_ip in DENIED_IP_ARRAY:
		# The server process will notice that the client socket is closed
		# and will pass the session after the end of this routine.
		print(f\(dqConnection closed for denied IP : {client_ip}\(dq)

		client_socket.close()

# Start the server
server.startServer()

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Set custom container capacity

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
from anwdlserver.core.server import ServerInterface

# Replace it with your own path
CONTAINER_ISO_PATH = \(dq/path/of/the/ISO/file.iso\(dq

# Create a new ServerInterface instance
server = ServerInterface(container_iso_path=CONTAINER_ISO_PATH)

# Print the message when the server is ready
@server.on_started
def notify_started(**kwargs):
	print(\(dqServer is started\(dq)

# Print a message when a request is received
@server_interface.on_request
def notify_request(**kwargs):
	request_verb = kwargs[\(dqclient_instance\(dq].getStoredRequest()
	
	print(\(dqReceived {} request\(dq.format(request_verb[\(dqverb\(dq]))

# Set created containers capacity with 2048 Mb of memory and 2 VCPUs
@server.on_container_created
def handle_container_creation(**kwargs):
	container_instance = kwargs.get(\(dqcontainer_instance\(dq)

	print(f\(dqNew container created : {container_instance.getUUID()}\(dq)

	container_instance.setMemory(2048)
	container_instance.setVCPUs(2)

# Start the server
server.startServer()

.ft P
.fi
.UNINDENT
.UNINDENT
.SS API references
.sp
Learn about every features that the Anweddol server can provide.
You can also see the \fITechnical specificatons\fP section to get every informations on how the Anweddol server works.
.SS Core features
.sp
The core features, also called \fBcore\fP, are every needed functionnalities that an Anweddol server must have in order to provide a valid service.
.SS Client

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Client management features
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.client\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
Default values :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
\fBDEFAULT_STORE_REQUEST\fP
T}	T{
\fBTrue\fP
T}	T{
Store the request in the instance by default
T}
_
T{
\fBDEFAULT_AUTO_EXCHANGE_KEYS\fP
T}	T{
\fBTrue\fP
T}	T{
Exchange keys on connection by default
T}
_
T{
\fBDEFAULT_RECEIVE_FIRST\fP
T}	T{
\fBTrue\fP
T}	T{
Receive the public key first by default
T}
_
.TE
.sp
Constants definition :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Definition
T}
_
T{
\fBMESSAGE_OK\fP
T}	T{
\fB\(dq1\(dq\fP
T}	T{
Message used during key exchange to transmit a state or an acknowledgement
T}
_
T{
\fBMESSAGE_NOK\fP
T}	T{
\fB\(dq0\(dq\fP
T}	T{
Message used during key exchange to transmit a state or an acknowledgement
T}
_
.TE
.SS Classes
.SS \fBClientInstance\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class ClientInstance(
	socket: socket.socket,
	timeout: int = None,
	rsa_wrapper: RSAWrapper = None,
	aes_wrapper: AESWrapper = None,
	auto_exchange_key: bool = DEFAULT_AUTO_EXCHANGE_KEYS,
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Represents a connected client
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBsocket\fP : The client socket descriptor. Must be a connected active client socket
.IP \(bu 2
\fBtimeout\fP : The timeout to apply to the client
.IP \(bu 2
\fBrsa_wrapper\fP : The \fBRSAWrapper\fP instance that will be used on the client
.IP \(bu 2
\fBaes_wrapper\fP : The \fBAESWrapper\fP instance that will be used on the client
.IP \(bu 2
\fBauto_exchange_key\fP : Automatically exchange keys on initialization
.UNINDENT
.sp
\fBNOTE\fP : The client socket will be automatically closed on \fB__del__\fP method. The parameter \fBsocket\fP must be a valid open socket descriptor representing a client connection.
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isClosed() \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if the client is closed
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
\fBTrue\fP if the server is closed, \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getSocketDescriptor() \-> socket.socket

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client socket descriptor
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The socket descriptor of the client
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getIP() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client IP
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The client IP as an IPv4 string
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getID() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client ID
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The client ID. It is the first 7 characters of the client’s IP SHA256 (see the administration guide \fI\%Logging section\fP to learn more).
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getTimestamp() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client creation timestamp
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP:
.INDENT 0.0
.IP \(bu 2
The creation timestamp
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getStoredRequest() \-> None | dict

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the stored request
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A dictionary following the normalized \fI\%Request format\fP or \fBNone\fP if there is none
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRSAWrapper() \-> RSAWrapper

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client \fBRSAWrapper\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP:
.INDENT 0.0
.IP \(bu 2
The \fBRSAWrapper\fP instance of the client
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getAESWrapper() \-> AESWrapper

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client \fBAESWrapper\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP:
.INDENT 0.0
.IP \(bu 2
The \fBAESWrapper\fP instance of the client
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setRSAWrapper(rsa_wrapper: RSAWrapper) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the client \fBRSAWrapper\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBrsa_wrapper\fP : The \fBRSAWrapper\fP instance to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setAESWrapper(aes_wrapper: AESWrapper) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the client \fBAESWrapper\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBaes_wrapper\fP : The \fBAESWrapper\fP instance to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sendPublicRSAKey() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Send the local public RSA key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
recvPublicRSAKey() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Receive the client public RSA key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBValueError\fP
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sendAESKey() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Send the local AES key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBValueError\fP
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
recvAESKey() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Receive the local AES key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBValueError\fP
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
exchangeKeys(receive_first: bool = DEFAULT_RECEIVE_FIRST) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Exchange the local RSA and AES keys with the client
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBreceive_first\fP : \fBTrue\fP to receive the public key first, \fBFalse\fP otherwise
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBValueError\fP
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sendResponse(
	success: bool,
	message: str,
	data: dict = {},
	reason: str = None
) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Send a response to the client
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBsuccess\fP : \fBTrue\fP to announce a success, \fBFalse\fP otherwise
.IP \(bu 2
\fBmessage\fP : The message to send
.IP \(bu 2
\fBdata\fP : The data to send. The content must be an empty dictionary or a normalized \fI\%Response format\fP dictionary.
.IP \(bu 2
\fBreason\fP : The reason to specify if \fBsuccess\fP is set to \fBFalse\fP\&. The value will be appended to the message like : \fBRefused request (reason : <specified_reason>)\fP
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBValueError\fP
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
recvRequest(store_request: bool = DEFAULT_STORE_REQUEST) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Receive a request from the client
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBstore_request\fP : Store the received request on instance or not
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The received request as a normalized \fI\%Request format\fP dictionary
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBValueError\fP
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
closeConnection() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Close the client connection
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : This method is automatically called within the \fB__del__\fP method, but it is programatically better to call it naturally
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.SS Cryptography

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
RSA / AES encryption features.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.crypto\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
Default values :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
\fBDEFAULT_RSA_KEY_SIZE\fP
T}	T{
\fB4096\fP
T}	T{
The default RSA key size
T}
_
T{
\fBDEFAULT_AES_KEY_SIZE\fP
T}	T{
\fB256\fP
T}	T{
The default AES key size
T}
_
T{
\fBDEFAULT_PEM_FORMAT\fP
T}	T{
\fBTrue\fP
T}	T{
Specify key in a PEM format by default
T}
_
T{
\fBDEFAULT_GENERATE_KEY_PAIR\fP
T}	T{
\fBTrue\fP
T}	T{
Generate key pair on initialization by default
T}
_
T{
\fBDEFAULT_DERIVATE_PUBLIC_KEY\fP
T}	T{
\fBFalse\fP
T}	T{
Derivate the public key out of the private key by default
T}
_
.TE
.SS Classes
.SS \fBRSAWrapper\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class RSAWrapper(
    key_size: int = DEFAULT_RSA_KEY_SIZE,
    generate_key_pair: bool = DEFAULT_GENERATE_KEY_PAIR
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Provides \fI\%RSA encryption\fP functionality
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBkey_size\fP : The RSA key size, exprimed in bits. Must be a multiple of 2
.IP \(bu 2
\fBgenerate_key_pair\fP : Generate RSA key pair on initialization or not
.UNINDENT
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
generateKeyPair(self) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Generate the RSA key pair
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getKeySize() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the local key size
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The key size exprimed in bytes
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getPublicKey(pem_format: bool = True) \-> str | bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the local public key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBpem_format\fP : \fBTrue\fP to return the local public key in a \fI\%PEM format\fP, \fBFalse\fP to return it as a byte sequence
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The local public key
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getPrivateKey(pem_format: bool = True) \-> str | bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the local private key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBpem_format\fP : \fBTrue\fP to return the local key in a \fI\%PEM format\fP, \fBFalse\fP to return it as a byte sequence
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The local private key
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRemotePublicKey(pem_format: bool = True) \-> None | str | bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the client public key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBpem_format\fP : \fBTrue\fP to return the client public key in a \fI\%PEM format\fP, \fBFalse\fP to return it as a byte sequence
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The client public key, or \fBNone\fP if there is none
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setPublicKey(public_key: str | bytes, pem_format: bool = True) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the local public key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBpublic_key\fP : The public key, in \fI\%PEM format\fP if the parameter \fBpem_format\fP is set to \fBTrue\fP, in a byte sequence otherwise
.IP \(bu 2
\fBpem_format\fP : Specify the format of the key in the parameter \fBpublic_key\fP\&. The key must be in \fI\%PEM format\fP if set to \fBTrue\fP, in a byte sequence otherwise
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : The intern private key will be deleted in the process, you must use \fBsetPrivateKey\fP to set the affiliated private key.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setPrivateKey(
    private_key: str | bytes,
    pem_format: bool = DEFAULT_PEM_FORMAT,
    derivate_public_key: bool = DEFAULT_DERIVATE_PUBLIC_KEY
) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the local private key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBprivate_key\fP : The private key, in \fI\%PEM format\fP if the parameter \fBpem_format\fP is set to \fBTrue\fP, in a byte sequence otherwise
.IP \(bu 2
\fBpem_format\fP : Specify the format of the key in the parameter \fBprivate_key\fP\&. The key must be in \fI\%PEM format\fP if set to \fBTrue\fP, in a byte sequence otherwise
.IP \(bu 2
\fBderivate_public_key\fP : Derivate the public key out of the private key or not
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setRemotePublicKey(
    remote_public_key: str | bytes,
    pem_format: bool = DEFAULT_PEM_FORMAT,
) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the client public key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBremote_public_key\fP : The remote public key, in \fI\%PEM format\fP if the parameter \fBpem_format\fP is set to \fBTrue\fP, in a byte sequence otherwise
.IP \(bu 2
\fBpem_format\fP : Specify the format of the key in the parameter \fBprivate_key\fP\&. The key must be in \fI\%PEM format\fP if set to \fBTrue\fP, in a byte sequence otherwise
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
encryptData(
    data: str | bytes,
    encode: bool = True,
    use_local_public_key: bool = False
) \-> bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Encrypt data
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBdata\fP : The data to encrypt. It can be a string or a byte sequence
.IP \(bu 2
\fBencode\fP : Specify if the content in parameter \fBdata\fP must be encoded before being processed (mus be set to \fBTrue\fP only if the parameter \fBdata\fP is a string)
.IP \(bu 2
\fBuse_local_public_key\fP : Specify if the local public key must be used for encryption instead of the remote public key
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The encrypted \fBdata\fP content as a byte sequence
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fBNOTE\fP : If the parameter \fBuse_local_public_key\fP is set to \fBFalse\fP, the remote public key must be set (\fBRuntimeError\fP will be raised otherwise)

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
decryptData(cipher: bytes, decode: bool = True) \-> str | bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Decrypt data
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcipher\fP : The encrypted cipher text as a byte sequence
.IP \(bu 2
\fBdecode\fP : Specify if the decrypted data should be decoded before being returned
.UNINDENT
.sp
\fIReturn value\fP
.INDENT 0.0
.IP \(bu 2
The decrypted \fBdata\fP content as a string or a byte sequence according to the value of \fBdecode\fP
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
signData(data: str | bytes, encode: bool = True) \-> bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Sign a block of data
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBdata\fP : The data to sign
.IP \(bu 2
\fBencode\fP : Specify if the content in parameter \fBdata\fP must be encoded before being processed (set to \fBTrue\fP only if the parameter \fBdata\fP is a string)
.UNINDENT
.sp
\fIPeturn value\fP :
.INDENT 0.0
.IP \(bu 2
The signed data, as a byte sequence
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
verifyDataSignature(
    signature: bytes,
    data: str | bytes,
    encode: bool = True
) \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Verify the authenticity of a signed block of data
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBsignature\fP : The signed data, as a byte sequence
.IP \(bu 2
\fBdata\fP : The data to verify
.IP \(bu 2
\fBencode\fP : Specify if the content in parameter \fBdata\fP must be encoded before being processed (set to \fBTrue\fP only if the parameter \fBdata\fP is a string)
.UNINDENT
.sp
\fIPeturn value\fP :
.INDENT 0.0
.IP \(bu 2
A boolean value : \fBTrue\fP if the data and its signature are authentic, \fBFalse\fP otherwise
.UNINDENT
.SS \fBAESWrapper\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class AESWrapper(key_size: int = DEFAULT_AES_KEY_SIZE)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Provides \fI\%AES encryption\fP functionality
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBkey_size\fP : The AES key size, exprimed in bytes. Must be 16, 24 or 32 bytes long
.UNINDENT
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getKeySize() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the key size
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The AES key size exprimed in bytes, as an integer
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getKey() \-> bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the AES key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The AES key as a byte sequence
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getIv() \-> bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the \fI\%Initialisation Vector\fP (Iv)
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The IV as a 16 byte sequence
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setKey(key: bytes, iv: bytes = None) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the AES key
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBkey\fP : The AES key, as a byte sequence. Must be 16, 24 or 32 bytes long
.IP \(bu 2
\fBiv\fP : The \fI\%Initialisation Vector\fP\&. Must be 16 bytes long
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : If the parameter \fBiv\fP is not set, it will be automatically generated

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
encryptData(data: str | bytes, encode: bool = True) \-> bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Encrypt data
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBdata\fP : The data to encrypt. It can be a string or a byte sequence
.IP \(bu 2
\fBencode\fP : Specify if the content in parameter \fBdata\fP must be encoded before being processed (set to \fBTrue\fP only if the parameter \fBdata\fP is a string)
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBdata\fP as a byte sequence
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
decryptData(self, cipher: bytes, decode: bool = True) \-> str | bytes

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Decrypt data
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP:
.INDENT 0.0
.IP \(bu 2
\fBcipher\fP: The encrypted cipher text as a byte sequence
.IP \(bu 2
\fBdecode\fP: Specify if the decrypted data should be decoded before being returned
.UNINDENT
.sp
\fIReturn value\fP
.INDENT 0.0
.IP \(bu 2
The decrypted \fBdata\fP content as a string or a byte sequence according to the value of \fBdecode\fP
.UNINDENT
.SS Database

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Database features with SQLite memory database
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.database\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
None
.SS Classes
.SS \fBDatabaseInterface\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class DatabaseInterface()

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Provides an \fI\%SQLAlchemy\fP memory database instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : The database and its engine will be automatically closed on \fB__del__\fP method. Also, queries implying modifications on the database are automatically committed, and rollbacks are called if an error occured.
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getEngine() \-> sqlalchemy.engine.Engine

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the SQLAlchemy \fI\%sqlalchemy.engine.Engine\fP object instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBsqlalchemy.engine.Engine\fP object of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getEngineConnection() \-> sqlalchemy.engine.Connection

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the SQLAlchemy \fI\%sqlalchemy.engine.Connection\fP object instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBsqlalchemy.engine.Connection\fP object of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRuntimeTableObject() \-> sqlalchemy.schema.Table

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the SQLAlchemy \fI\%sqlalchemy.schema.Table\fP object instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBsqlalchemy.schema.Table\fP object of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getEntryID(container_uuid: str, client_token: str) \-> None | int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the credentials pair entry ID[1]
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_uuid\fP : The clear \fI\%container UUID\fP
.IP \(bu 2
\fBclient_token\fP : The clear \fI\%client token\fP
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The credentials entry ID[1] if exists, \fBNone\fP otherwise
.UNINDENT
.sp
\fBNOTE\fP : This method must be used for client credentials verification.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getValueEntryID(value: str) \-> None | int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the entry ID[1] of a specific value
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBvalue\fP : The value to search for. It can be a \fI\%container UUID\fP or a \fI\%client token\fP
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The hashed value entry ID[1] if exists, \fBNone\fP otherwise
.UNINDENT
.sp
\fBNOTE\fP : Only the \fBContainerUUID\fP and the \fBClientToken\fP columns values are concerned by this method

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getEntry(entry_id: int) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get an entry content
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID[1] to get the credentials from
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the entry content :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	entry_id,
	creation_timestamp,
	container_uuid,
	client_token
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID[1]
.IP \(bu 2
\fBcreation_timestamp\fP : The entry creation timestamp
.IP \(bu 2
\fBcontainer_uuid\fP : The hashed \fI\%container UUID\fP
.IP \(bu 2
\fBclient_token\fP : The hashed \fI\%client token\fP
.UNINDENT
.sp
\fBNOTE\fP : The \fBcontainer_uuid\fP and the \fBclient_token\fP values are hashed with SHA256 as described in the \fI\%Technical specifications\fP\&.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
addEntry(container_uuid: str) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Add an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_uuid\fP : The \fI\%container UUID\fP to add
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the infomations of the created entry :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	entry_id,
	creation_timestamp,
	client_token
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The new entry ID[1]
.IP \(bu 2
\fBcreation_timestamp\fP : The entry creation timestamp
.IP \(bu 2
\fBclient_token\fP : The [client token]https://anweddol\-server.readthedocs.io/en/latest/technical_specifications/core/client_authentication.html#session\-credentials), in plain text
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBLookupError\fP
.UNINDENT
.sp
\fBNOTE\fP : If the \fBcontainer_uuid\fP is already specified on the database, \fBLookupError\fP is raised. Since the \fI\%client tokens\fP are hashed in the database (see the technical specifications \fI\%Database section\fP to learn more), there’s no way to see them again in plain text : Store this clear created token somewhere safe in order to use it for further operations.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
listEntries() \-> list

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
List entries
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A list of tuples representing the entries partial informations :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	entry_id,
	creation_timestamp
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The created entry ID[1]
.IP \(bu 2
\fBcreation_timestamp\fP : The entry creation timestamp
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
updateEntry(entry_id: int, container_uuid: str, client_token: str)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Update an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID[1] to update
.IP \(bu 2
\fBcontainer_uuid\fP : The \fI\%container UUID\fP to set
.IP \(bu 2
\fBclient_token\fP : THe \fI\%client token\fP to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
deleteEntry(entry_id: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Delete an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID[1] to delete
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
closeDatabase() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Close the database instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : This method is automatically called within the \fB__del__\fP method, but it is programatically better to call it naturally

.sp
.ce
----

.ce 0
.sp
.IP [1] 5
Similar to the ROWID in sqlite, identifies the row
.SS Sanitization

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Normalized request / response values and formats
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.sanitize\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
None
.SS Functions
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
verifyRequestContent(request_dict: dict) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if a request dictionary is a valid normalized \fI\%Request format\fP
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBrequest_dict\fP : The request dictionary
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the verification results :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	True,
	sanitized_request_dictionary
)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
if the \fBrequest_dict\fP is a valid normalized \fI\%Request format\fP,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	False,
	errors_dictionary
)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
otherwise.
.INDENT 0.0
.IP \(bu 2
\fBsanitized_request_dictionary\fP : The sanitized request as a normalized \fI\%Request format\fP dictionary.
.IP \(bu 2
\fBerrors_dictionary\fP : A dictionary depicting the errors detected in \fBrequest_dict\fP according to the \fI\%Cerberus\fP error format.
.UNINDENT
.sp
\fBNOTE\fP : The function \fBverifyRequestContent\fP does not use strict verification. It only checks if the required keys and values exist and are correct, but it is open to unknown keys or structures for the developer to be able to implement its own mechanisms (see the technical specifications \fI\%Sanitization section\fP to learn more).

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
makeResponse(
    success: bool,
    message: str,
    data: dict = {},
    reason: str = None
) \-> tuple:

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Make a normalized response dictionary
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBsuccess\fP : \fBTrue\fP to announce a success, \fBFalse\fP otherwise
.IP \(bu 2
\fBmessage\fP : The message to send
.IP \(bu 2
\fBdata\fP : The data to send. The content must be an empty dict or a normalized \fI\%Response format\fP\&.
.IP \(bu 2
\fBreason\fP : The reason to specify if \fBsuccess\fP is set to \fBFalse\fP\&. The value will be appended to the message like : \fBRefused request (reason : <specified_reason>)\fP
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing a valid \fI\%Response format\fP dictionary :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	True,
	response_dictionary
)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
if the operation succeeded,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	False,
	errors_dictionary
)

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
otherwise.
.INDENT 0.0
.IP \(bu 2
\fBresponse_dictionary\fP : The response dictionary as a normalized \fI\%Response format\fP\&.
.IP \(bu 2
\fBerrors_dictionary\fP : A dictionary depicting the errors detected in parameters according to the \fI\%Cerberus\fP error format.
.UNINDENT
.sp
\fBNOTE\fP : The \fBsendResponse\fP method from \fBClientInstance\fP wraps this function in its process. Like \fBverifyRequestContent\fP, the method only checks if the required keys and values exist and are correct, but it is open to unknown keys or structures for the developer to be able to implement its own mechanisms.
.SS Server

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Server management features
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.server\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
Default values :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
\fBDEFAULT_SERVER_BIND_ADDRESS\fP
T}	T{
\fB\(dq\(dq\fP
T}	T{
The default server bind address
T}
_
T{
\fBDEFAULT_SERVER_LISTEN_PORT\fP
T}	T{
\fB6150\fP
T}	T{
The default server listen port
T}
_
T{
\fBDEFAULT_CLIENT_TIMEOUT\fP
T}	T{
\fB10\fP
T}	T{
The default timeout applied on a new client
T}
_
T{
\fBDEFAULT_ASYCHRONOUS\fP
T}	T{
\fBFalse\fP
T}	T{
Start the server asynchronously by default
T}
_
.TE
.sp
Constants definition :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
\fBREQUEST_VERB_CREATE\fP
T}	T{
\fB\(dqCREATE\(dq\fP
T}	T{
The verb indicating the intent to create a new container
T}
_
T{
\fBREQUEST_VERB_DESTROY\fP
T}	T{
\fB\(dqDESTROY\(dq\fP
T}	T{
The verb indicating the intent to destroy a container
T}
_
T{
\fBREQUEST_VERB_STAT\fP
T}	T{
\fB\(dqSTAT\(dq\fP
T}	T{
The verb indicating the intent to get the server runtime statistics
T}
_
T{
\fBRESPONSE_MSG_OK\fP
T}	T{
\fB\(dqOK\(dq\fP
T}	T{
Message specifying that the request was correctly handled by the server
T}
_
T{
\fBRESPONSE_MSG_BAD_AUTH\fP
T}	T{
\fB\(dqBad authentication\(dq\fP
T}	T{
Message specifying that invalid credentials were given to the server
T}
_
T{
\fBRESPONSE_MSG_BAD_REQ\fP
T}	T{
\fB\(dqBad request\(dq\fP
T}	T{
Message specifying that the received request is malformed
T}
_
T{
\fBRESPONSE_MSG_REFUSED_REQ\fP
T}	T{
\fB\(dqRefused request\(dq\fP
T}	T{
Message specifying that the received request was refused
T}
_
T{
\fBRESPONSE_MSG_UNAVAILABLE\fP
T}	T{
\fB\(dqUnavailable\(dq\fP
T}	T{
Message specifying that the server is currently unavailable
T}
_
T{
\fBRESPONSE_MSG_INTERNAL_ERROR\fP
T}	T{
\fB\(dqInternal error\(dq\fP
T}	T{
Message specifying that the server experienced an internal error
T}
_
T{
\fBEVENT_CLIENT\fP
T}	T{
\fB1\fP
T}	T{
Identifies the \fBon_client\fP callback method
T}
_
T{
\fBEVENT_CLIENT_CLOSED\fP
T}	T{
\fB2\fP
T}	T{
Identifies the \fBon_client_closed\fP callback method
T}
_
T{
\fBEVENT_CONNECTION\fP
T}	T{
\fB3\fP
T}	T{
Identifies the \fBon_connection\fP callback method
T}
_
T{
\fBEVENT_CREATED_CONTAINER\fP
T}	T{
\fB4\fP
T}	T{
Identifies the \fBon_created_container\fP callback method
T}
_
T{
\fBEVENT_CREATED_ENDPOINT_SHELL\fP
T}	T{
\fB5\fP
T}	T{
Identifies the \fBon_created_endpoint_shell\fP callback method
T}
_
T{
\fBEVENT_DESTROYED_CONTAINER\fP
T}	T{
\fB6\fP
T}	T{
Identifies the \fBon_destroyed_container\fP callback method
T}
_
T{
\fBEVENT_MALFORMED_REQUEST\fP
T}	T{
\fB7\fP
T}	T{
Identifies the \fBon_malformed_request\fP callback method
T}
_
T{
\fBEVENT_REQUEST\fP
T}	T{
\fB8\fP
T}	T{
Identifies the \fBon_request\fP callback method
T}
_
T{
\fBEVENT_RUNTIME_ERROR\fP
T}	T{
\fB9\fP
T}	T{
Identifies the \fBon_runtime_error\fP callback method
T}
_
T{
\fBEVENT_STARTED\fP
T}	T{
\fB10\fP
T}	T{
Identifies the \fBon_started\fP callback method
T}
_
T{
\fBEVENT_STOPPED\fP
T}	T{
\fB11\fP
T}	T{
Identifies the \fBon_stopped\fP callback method
T}
_
T{
\fBEVENT_UNKNOWN_VERB\fP
T}	T{
\fB12\fP
T}	T{
Identifies the \fBon_unknown_verb\fP callback method
T}
_
.TE
.SS Classes
.SS \fBServerInterface\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class ServerInterface(
	container_iso_path: str = None,
	bind_address: str = DEFAULT_SERVER_BIND_ADDRESS,
	listen_port: int = DEFAULT_SERVER_LISTEN_PORT,
	client_timeout: int = DEFAULT_CLIENT_TIMEOUT,
	runtime_virtualization_interface: VirtualizationInterface = None,
	runtime_database_interface: DatabaseInterface = None,
	runtime_rsa_wrapper: RSAWrapper = None
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Main server utility class
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_iso_path\fP : The container ISO path that will be used for containers
.IP \(bu 2
\fBbind_address\fP : The bind address that the server will be using
.IP \(bu 2
\fBlisten_port\fP : The listen port that the server will be using
.IP \(bu 2
\fBclient_timeout\fP : The timeout that will be applied to clients
.IP \(bu 2
\fBruntime_virtualization_interface\fP : The \fBVirtualizationInterface\fP instance that will be used by the server
.IP \(bu 2
\fBruntime_database_interface\fP : The \fBDatabaseInterface\fP instance that will be used by the server
.IP \(bu 2
\fBruntime_rsa_wrapper\fP : The \fBRSAWrapper\fP instance that will be used by the server
.UNINDENT
.sp
\fBNOTE\fP : The container ISO path must point to a valid \fI\%ISO image\fP\&. The server is automatically stopped when the \fB__del__\fP method is called.
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRuntimeDatabaseInterface() \-> DatabaseInterface

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Returns the runtime \fBDatabaseInterface\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBDatabaseInterface\fP instance used by the server
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRuntimeVirtualizationInterface() \-> VirtualizationInterface

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Returns the runtime \fBVirtualizationInterface\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBVirtualizationInterface\fP instance used by the server
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRuntimeRSAWrapper() \-> RSAWrapper

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Returns the runtime \fBRSAWrapper\fP instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBRSAWrapper\fP instance used by the server
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRuntimeStatistics() \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Returns the server’s actual runtime statistics
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP:
.INDENT 0.0
.IP \(bu 2
A tuple containing the server runtime statistics :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	is_running,
	recorded_runtime_errors_amount,
	uptime,
	available_containers_amount
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBis_running\fP : Boolean value set to \fBTrue\fP if the server is currently running, \fBFalse\fP otherwise
.IP \(bu 2
\fBrecorded_runtime_errors_amount\fP : The amount of errors recorded during the runtime
.IP \(bu 2
\fBuptime\fP : The server uptime, exprimed in seconds
.IP \(bu 2
\fBavailable_containers_amount\fP : The available containers amount
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setRequestHandler(verb: str, routine: callable) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set a request handler
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBverb\fP : The request verb to handle. It can be a custom one or a normalized one :
.INDENT 2.0
.IP \(bu 2
\fBREQUEST_VERB_CREATE\fP
.IP \(bu 2
\fBREQUEST_VERB_STAT\fP
.IP \(bu 2
\fBREQUEST_VERB_DESTROY\fP
.UNINDENT
.IP \(bu 2
\fBroutine\fP : A callable object that will be called when a received request verb is equal to \fBverb\fP value
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setEventHandler(event: int, routine: callable) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set an event handler
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBevent\fP : The event to handle. It can be :
.INDENT 2.0
.IP \(bu 2
\fBEVENT_MALFORMED_REQUEST\fP
.IP \(bu 2
\fBEVENT_UNKNOWN_VERB\fP
.IP \(bu 2
\fBEVENT_RUNTIME_ERROR\fP
.IP \(bu 2
\fBEVENT_REQUEST\fP
.IP \(bu 2
\fBEVENT_CONNECTION\fP
.IP \(bu 2
\fBEVENT_CREATED_CONTAINER\fP
.IP \(bu 2
\fBEVENT_CREATED_ENDPOINT_SHELL\fP
.IP \(bu 2
\fBEVENT_CLIENT\fP
.IP \(bu 2
\fBEVENT_STARTED\fP
.IP \(bu 2
\fBEVENT_STOPPED\fP
.IP \(bu 2
\fBEVENT_CLIENT_CLOSED\fP
.IP \(bu 2
\fBEVENT_DESTROYED_CONTAINER\fP
.UNINDENT
.IP \(bu 2
\fBroutine\fP : A callable object that will be called when the \fBevent\fP event is triggered.
.UNINDENT
.sp
\fBNOTE\fP : This is the alternative of callback event decorators. Refer to the \fI\%Callback events\fP section below to know their roles and effects.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
startServer(asynchronous: bool = DEFAULT_ASYCHRONOUS) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Start the server
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBasynchronous\fP : Start the server asynchronously. Default is \fBFalse\fP, executing it synchronously
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : The execution is blocked when set to synchronous mode (by default)

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
stopServer() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Stop the server
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP:
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : This method is automatically called within the \fB__del__\fP method, but it is programatically better to call it naturally

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
restartServer(asynchronous: bool = DEFAULT_ASYCHRONOUS) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Restart the server
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBasynchronous\fP : Start the server asynchronously. Default is \fBFalse\fP, executing it synchronously
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.SS Callback events
.sp
Callback events are decorators used to bind a routine or a callable object to an intern event.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# The decorator depicting the event. Here EVENT_CREATED_CONTAINER
@ServerInterface.on_created_container
def routine(**kwargs):
	# The routine that will be executed when the event will be triggered
	...

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Arguments provided to routines are different depending of the callback used.
That’s why it is recommended to use \fB**kwargs\fP and to refer to the documentation to know the names of the passed parameters.
.sp
\fBNOTE\fP : When a client instance or raw socket is closed during a callback routine, the main server process will detect it, automatically terminating the session as a result. It is the same for container shell instances.
.sp
To have a proper example on how to use these decorators, see the \fIBasic server\fP on the examples section.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_client

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when a new client is connected and the keys are exchanged
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_CLIENT\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_client_closed

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when a connected client was closed
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance Callback events representing the client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_CLIENT_CLOSED\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_connection

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when a new client is connected and the keys have not been exchanged yet
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_socket\fP : The raw client socket instance
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_CONNECTION\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_created_container

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when a new container instance is created
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.IP \(bu 2
\fBcontainer_instance\fP : The \fBContainerInstance\fP instance of the created container
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_CREATED_CONTAINER\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_created_endpoint_shell

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when an endpoint shell was opened on a container
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBendpoint_shell_instance\fP : The \fBEndpointShellInstance\fP on the container
.IP \(bu 2
\fBcontainer_instance\fP : The \fBContainerInstance\fP instance representing the affiliated container
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_CREATED_ENDPOINT_SHELL\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_destroyed_container

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when a container was destroyed
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.IP \(bu 2
\fBcontainer_instance\fP : The \fBContainerInstance\fP instance representing the affiliated container
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_DESTROYED_CONTAINER\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_malformed_request

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when the server has received a malformed request
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_MALFORMED_REQUEST\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_request

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when the server receives a request
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_REQUEST\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_runtime_error

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when an exception was raised during the server process
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBtraceback\fP : The exception traceback
.IP \(bu 2
(optional) \fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_RUNTIME_ERROR\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_started

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when the server is started and ready to operate
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_STARTED\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_stopped

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when the server was stopped
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_STOPPED\fP

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
@ServerInterface.on_unknown_verb

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Triggered when the server has received an unknown or unsupported verb
.UNINDENT
.UNINDENT
.sp
\fIProvided parameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBclient_instance\fP : The \fBClientInstance\fP instance representing the affiliated client
.UNINDENT
.sp
\fIAffiliated constant\fP : \fBEVENT_UNKNOWN_VERB\fP
.SS Utilities

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Miscellaneous features
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.util\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
None
.SS Functions
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isPortBindable(port: int) \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if a port is bindable
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBport\fP : The port to check. It must be an integer between 1 and 65535
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
\fBTrue\fP if the port is bindable, \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isSocketClosed(socket_descriptor: socket.socket) \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if a socket descriptor is closed
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBsocket_descriptor\fP : The socket descriptor to check
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
\fBTrue\fP if the socket descriptor is closed, \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isValidIP(ip: str) \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if the IP is a valid IPv4 format
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBip\fP : The IP to check as a string
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
\fBTrue\fP if the IP is valid , \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isInterfaceExists(interface_name: str) \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if the network interface exists on the system
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBinterface_name\fP : The interface name to check as a string
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
\fBTrue\fP if the interface exists , \fBFalse\fP otherwise
.UNINDENT
.SS Virtualization

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Virtualization management and utilities, using libvirt API
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.core.virtualization\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
Default parameters :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
\fBDEFAULT_LIBVIRT_DRIVER_URI\fP
T}	T{
\fB\(dqqemu:///system\(dq\fP
T}	T{
The default server bind address
T}
_
T{
\fBDEFAULT_CONTAINER_ENDPOINT_USERNAME\fP
T}	T{
\fB\(dqendpoint\(dq\fP
T}	T{
The default server listen port
T}
_
T{
\fBDEFAULT_CONTAINER_ENDPOINT_PASSWORD\fP
T}	T{
\fB\(dqendpoint\(dq\fP
T}	T{
The default timeout applied on a new client
T}
_
T{
\fBDEFAULT_CONTAINER_ENDPOINT_LISTEN_PORT\fP
T}	T{
\fB22\fP
T}	T{
Start the server asynchronously by default
T}
_
T{
\fBDEFAULT_BRIDGE_INTERFACE_NAME\fP
T}	T{
\fB\(dqanwdlbr0\(dq\fP
T}	T{
The default bridge interface name that container domains will use
T}
_
T{
\fBDEFAULT_NAT_INTERFACE_NAME\fP
T}	T{
\fB\(dqvirbr0\(dq\fP
T}	T{
The default NAT interface name that container domains will use
T}
_
T{
\fBDEFAULT_CONTAINER_MAX_TRYOUT\fP
T}	T{
\fB20\fP
T}	T{
The maximum attemps to check the network availability of a container domain before error
T}
_
T{
\fBDEFAULT_MAX_ALLOWED_CONTAINERS\fP
T}	T{
\fB6\fP
T}	T{
The maximum allowed amount of active containers on an instance
T}
_
T{
\fBDEFAULT_CONTAINER_MEMORY\fP
T}	T{
\fB2048\fP
T}	T{
The memory, in Mb, allocated to container domains
T}
_
T{
\fBDEFAULT_CONTAINER_VCPUS\fP
T}	T{
\fB2\fP
T}	T{
The amount of VCPUs allocated to container domains
T}
_
T{
\fBDEFAULT_CONTAINER_PORT_RANGE\fP
T}	T{
\fBrange(10000, 15000)\fP
T}	T{
The port range that will be assigned to container domains SSH servers
T}
_
T{
\fBDEFAULT_CONTAINER_WAIT_AVAILABLE\fP
T}	T{
\fBTrue\fP
T}	T{
Wait for the network to be available on a container domain before continuing by default
T}
_
T{
\fBDEFAULT_CONTAINER_DESTROY_DOMAIN\fP
T}	T{
\fBTrue\fP
T}	T{
Destroy the domain rather than shutting it down by default
T}
_
T{
\fBDEFAULT_STORE_CONTAINER\fP
T}	T{
\fBTrue\fP
T}	T{
Store the container instance on the virtualization interface or not by default
T}
_
.TE
.SS Classes
.SS \fBEndpointShellInstance\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class EndpointShellInstance(
	ssh_client: paramiko.client.SSHClient
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Represents a opened SSH shell to a container endpoint
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBssh_client\fP: The \fI\%paramiko.client.SSHClient\fP instance representing the SSH connection.
.UNINDENT
.sp
\fBNOTE\fP : The endpoint SSH shell will be automatically closed on \fB__del__\fP method.
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isClosed() \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if the connection is closed
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A boolean value. \fBTrue\fP if the connection is closed, \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getSSHClient() \-> paramiko.client.SSHClient

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the \fI\%paramiko.client.SSHClient\fP connection object
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fI\%paramiko.client.SSHClient\fP object of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getStoredContainerSSHCredentials() \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the stored container SSH credentials
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the stored container SSH credentials :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	username,
	password,
	listen_port
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBusername\fP : The SSH username
.IP \(bu 2
\fBpassword\fP : The SSH password
.IP \(bu 2
\fBlisten_port\fP : The SSH server listen port
.UNINDENT
.sp
\fBNOTE\fP : Container SSH credentials are stored on the instance within the \fBsetContainerSSHCredentials\fP method. For these credentials to be sent to the client in the server process, you need to call this method if you want to set specific credentials.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
executeCommand(command: str) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Execute a command on the remote container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcommand\fP : The command to execute
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the stdout and the stderr of the command output :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	stdout,
	stderr
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBstdout\fP : The standard output stream of the result
.IP \(bu 2
\fBstderr\fP : The standard error stream of the result
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
generateContainerSSHCredentials(
	port_range: range = DEFAULT_CONTAINER_PORT_RANGE,
) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Generate new container SSH credentials
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBport_range\fP : The port range which a random new listen port is chosen
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the generated container SSH credentials :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	username,
	password,
	listen_port
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBusername\fP : The SSH username
.IP \(bu 2
\fBpassword\fP : The SSH password
.IP \(bu 2
\fBlisten_port\fP : The SSH server listen port
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setContainerSSHCredentials(
	username: str,
    password: str,
    listen_port: int,
) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the container SSH credentials on the remote container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBusername\fP : The SSH username to set
.IP \(bu 2
\fBpassword\fP : The SSH password to set
.IP \(bu 2
\fBlisten_port\fP : The SSH server listen port to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : This method uses the \fBanweddol_container_setup.sh\fP script on the container to set the SSH credentials on ot, thus calling the \fBcloseShell\fP method after completion (see the technical specifications \fI\%Virtualization section\fP) to learn more).

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
closeShell() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Close the SSH connection
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : This method is automatically called within the \fB__del__\fP method and the \fBsetContainerSSHCredentials\fP method when called, but it is programatically better to call it naturally
.SS \fBContainerInstance\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class ContainerInstance(
	uuid: str,
	iso_path: str,
	memory: int = DEFAULT_CONTAINER_MEMORY,
	vcpus: int = DEFAULT_CONTAINER_VCPUS,
	nat_interface_name: str = DEFAULT_NAT_INTERFACE_NAME,
	bridge_interface_name: str = DEFAULT_BRIDGE_INTERFACE_NAME,
	endpoint_username: str = DEFAULT_CONTAINER_ENDPOINT_USERNAME,
	endpoint_password: str = DEFAULT_CONTAINER_ENDPOINT_PASSWORD,
	endpoint_listen_port: int = DEFAULT_CONTAINER_ENDPOINT_LISTEN_PORT
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Represents a container instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBuuid\fP : The new \fI\%container UUID\fP
.IP \(bu 2
\fBiso_path\fP : The ISO path that will be used for the container domain
.IP \(bu 2
\fBmemory\fP : The memory amount to allocate on the container, exprimed in Mb
.IP \(bu 2
\fBvcpus\fP : The VCPUs amount to allocate on the container
.IP \(bu 2
\fBnat_interface_name\fP : The \fI\%NAT interface name\fP that will be used by the container
.IP \(bu 2
\fBbridge_interface_name\fP : \fI\%The bridge interface\fP name that will be used by the container
.IP \(bu 2
\fBendpoint_username\fP : The \fI\%endpoint username\fP that will be used for container administration
.IP \(bu 2
\fBendpoint_password\fP : The \fI\%endpoint password\fP that will be used for container administration
.IP \(bu 2
\fBendpoint_listen_port\fP : The \fI\%endpoint listen port\fP that will be used for container administration
.UNINDENT
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
isDomainRunning() \-> bool

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Check if the container domain is running
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A boolean value. \fBTrue\fP if the domain is running, \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getNATInterfaceName() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the NAT interface name of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The NAT interface name of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getBridgeInterfaceName() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the bridge interface name of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The bridge interface name of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getDomainDescriptor() \-> None | libvirt.virDomain

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the \fBlibvirt.virDomain\fP object of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBlibvirt.virDomain\fP object of the instance, or \fBNone\fP is unavailable
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getUUID() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the instance \fI\%container UUID\fP
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fI\%container UUID\fP of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getISOPath() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the instance ISO path
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The instance ISO path on local storage
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getMAC() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the container MAC address
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The instance container MAC address
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fBNOTE\fP : The container domain must be started and ready in order to get its MAC address.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getIP() \-> None | str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the container IP address
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The instance container IP address, or \fBNone\fP if the domain is not started or not ready yet
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fBNOTE\fP : The container domain must be started and ready in order to get its IP, since the method will fetch it from the dnsmasq interface status file located in \fB/var/lib/libvirt/dnsmasq/\fP with its MAC address.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getMemory() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the allocated container memory amount
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The memory amount allocated to the container
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getVCPUs() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the allocated container Virtual CPUs amount
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The VCPUs amount allocated to the container
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setDomainDescriptor(domain_descriptor: libvirt.virDomain) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the \fBlibvirt.virDomain\fP object of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBdomain_descriptor\fP : The \fBlibvirt.virDomain\fP object to set on the instance
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setISOPath(iso_path: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the container ISO path of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBiso_path\fP : The ISO path to set on the instance
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setMemory(memory: int) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the memory amount to allocate on the container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBmemory\fP : The memory to allocate on the container, exprimed in Mb
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : The parameter \fBmemory\fP must be a value greater than 0

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setVCPUs(vcpus: int) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the Virtual CPUs amount to allocate on the container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBvcpus\fP : The amount of VCPUs to allocate on the container
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : The parameter \fBvcpus\fP must be a value greater than 0

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setNATInterfaceName(nat_interface_name: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the NAT interface name of the container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBnat_interface_name\fP : The NAT interface name that will be used on the container domain
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setBridgeInterfaceName(bridge_interface_name: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the bridge interface name of the container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBbridge_interface_name\fP : The bridge interface name that will be used on the container domain
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setEndpointSSHAuthenticationCredentials(
	endpoint_username: str = DEFAULT_CONTAINER_ENDPOINT_USERNAME, 
    endpoint_password: str = DEFAULT_CONTAINER_ENDPOINT_PASSWORD, 
    endpoint_listen_port: str = DEFAULT_CONTAINER_ENDPOINT_LISTEN_PORT
) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the container \fI\%endpoint SSH credentials\fP for SSH authentication
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBendpoint_username\fP : The endpoint username to set
.IP \(bu 2
\fBendpoint_password\fP : The endpoint password to set
.IP \(bu 2
\fBendpoint_listen_port\fP : The endpoint listen port to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
makeISOChecksum() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the SHA256 digest of the instance container ISO
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The SHA256 digest of the container ISO
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
createEndpointShell() \-> EndpointShellInstance

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Create a \fBEndpointShellInstance\fP object on the running container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBEndpointShellInstance\fP object representing the SSH shell on the container domain endpoint
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
startDomain(
	wait_available: bool = DEFAULT_CONTAINER_WAIT_AVAILABLE,
    wait_max_tryout: int = DEFAULT_CONTAINER_MAX_TRYOUT,
    driver_uri: str = DEFAULT_LIBVIRT_DRIVER_URI
) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Start the \fI\%container domain\fP
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBwait_available\fP : Wait for the network to be available on the domain or not
.IP \(bu 2
\fBwait_max_tryout\fP : The amount of attemps to check if the network is available on the domain before raising \fBTimeoutError\fP
.IP \(bu 2
\fBdriver_uri\fP : The hypervisor \fI\%driver URI\fP to use.
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.IP \(bu 2
\fBTimeoutError\fP
.UNINDENT
.sp
\fBNOTE\fP : By default, the qemu hypervisor URI \fBqemu:///system\fP is used. The container domain must be stopped before being started.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
stopDomain(destroy: bool = DEFAULT_CONTAINER_DESTROY_DOMAIN) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Stop the container domain
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBdestroy\fP : Destroy the container domain rather than shutting it down or not
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fBNOTE\fP : The container domain must be running before being stopped.
.SS \fBVirtualizationInterface\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class VirtualizationInterface(
	container_iso_path: str,
    max_allowed_containers: int = DEFAULT_MAX_ALLOWED_CONTAINERS,
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Provides container management functionality
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_iso_path\fP : The container ISO path to set on created containers
.IP \(bu 2
\fBmax_allowed_containers\fP : The maximum allowed active containers amount on the instance, must be greater than 0
.UNINDENT
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getIsoPath() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the instance ISO path
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The instance ISO path
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getMaxAllowedContainersAmount() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the maximum allowed active containers amount on the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The maximum allowed active containers amount on the instance, is greater than 0
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getContainersAmount() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the active containers amount on the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The amount of active containers on the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getAvailableContainersAmount() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the amount of available containers left
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The amount of available containers left
.UNINDENT
.sp
\fBNOTE\fP : This method justs substract the maximum allowed active containers amount on the instance with the actual active containers amount.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
listStoredContainers() \-> list

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
List stored containers
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A list enumerating the stored container UUIDs
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getStoredContainer(container_uuid: str) \-> None | ContainerInstance

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get a stored container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_uuid\fP : The container UUID to search for
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBContainerInstance\fP object of the crated container if exists, \fBNone\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setIsoPath(iso_path: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the instance ISO path
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBiso_path\fP : The instance ISO path to set. Must point to a valid ISO image
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setMaxAllowedContainers(max_allowed_containers: int) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the maximum allowed active container amount on the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBmax_allowed_containers\fP : The maximum allowed active containers amount on the instance, must be greater than 0
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
addStoredContainer(container_instance: ContainerInstance) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Add a container on the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_instance\fP : The \fBContainerInstance\fP object to add
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fBNOTE\fP : If the stored container amount become equal to the \fBmax_allowed_containers\fP value from the class initialization, a \fBRuntimeError\fP will be raised.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
deleteStoredContainer(container_uuid: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Delete a stored container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_instance\fP : The \fI\%container UUID\fP to delete
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
createContainer(store: bool = DEFAULT_STORE_CONTAINER) \-> ContainerInstance

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Create a container
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBstore\fP : \fBTrue\fP to store the created container, \fBFalse\fP otherwise
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBContainerInstance\fP object of the created container
.UNINDENT
.sp
\fIPossible raise classes\fP :
.INDENT 0.0
.IP \(bu 2
\fBRuntimeError\fP
.UNINDENT
.sp
\fBNOTE\fP : If the stored container amount become equal to the \fBmax_allowed_containers\fP value from the class initialization, a \fBRuntimeError\fP will be raised.
.SS Tools features
.sp
The \fBtools\fP features are additional functionnalities (authentication, ISO management, …) coming with the Anweddol server package.
.SS Access token

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Access token management features
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.tools.accesstk\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
Default values :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
\fBDEFAULT_DISABLE_TOKEN\fP
T}	T{
\fBFalse\fP
T}	T{
Enable created tokens by default
T}
_
.TE
.SS Classes
.SS \fBAccessTokenManager\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class AccessTokenManager(auth_token_db_path: str) 

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Provides access token features
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBauth_token_db_path\fP : The access tokens database file path
.UNINDENT
.sp
\fBNOTE\fP : The database and its cursors will be automatically closed on \fB__del__\fP method. Also, queries implying modifications on the database are automatically committed, and rollbacks are called if an error occured.
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getDatabaseConnection() \-> sqlite3.Connection

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the \fI\%sqlite3.Connection\fP object of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBsqlite3.Connection\fP object of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getCursor() \-> sqlite3.Cursor:

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the \fI\%sqlite3.Cursor\fP object of the instance
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The \fBsqlite3.Cursor\fP object of the instance
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getEntryID(access_token: str) \-> None | int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the access token entry ID (similar to the ROWID in sqlite, identifies the row)
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBaccess_token\fP : The clear access token to search for
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The access token entry ID if exists, \fBNone\fP otherwise
.UNINDENT
.sp
\fBNOTE\fP : This method must be used for client access verification. If the access token entry is disabled, the method will ignore the entry and return \fBNone\fP as a result.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getEntry(entry_id: int) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get an entry content
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID to get
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the entry content :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	entry_id,
	creation_timestamp,
	access_token,
	enabled
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID
.IP \(bu 2
\fBcreation_timestamp\fP : The entry creation timestamp
.IP \(bu 2
\fBaccess_token\fP : The hashed access token
.IP \(bu 2
\fBenabled\fP : A boolean value (\fB1\fP or \fB0\fP) depicting if the entry is enabled or not
.UNINDENT
.sp
\fBNOTE\fP : The \fBaccess_token\fP value is hashed with SHA256 as described in the \fI\%Technical specifications\fP\&.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
addEntry(disable: bool = DEFAULT_DISABLE_TOKEN) \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Create an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBdisable\fP : \fBTrue\fP to disable the token entry by default, \fBFalse\fP otherwise
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple representing the created token entry informations :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	entry_id, 
	auth_token
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The created entry ID
.IP \(bu 2
\fBauth_token\fP : The created access token, in plain text
.UNINDENT
.sp
\fBNOTE\fP : Since tokens are hashed with SHA256 in the database (see the technical specifications \fI\%Access token\fP section to learn more), there’s no way to see them again in plain text : Store this clear created token somewhere safe in order to use it for further operations.

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
listEntries() \-> list

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
List entries
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A list of tuples representing every entries on the database :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	entry_id,
	creation_timestamp,
	enabled
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID
.IP \(bu 2
\fBcreation_timestamp\fP : The entry creation timestamp
.IP \(bu 2
\fBenabled\fP : \fBTrue\fP if the entry is enabled, \fBFalse\fP otherwise
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
enableEntry(entry_id: int) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Enable the usage of an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID to enable
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
disableEntry(entry_id: int) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Disable the usage of an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID to disable
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
deleteEntry(entry_id: int) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Delete an entry
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBentry_id\fP : The entry ID to delete on the database
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
closeDatabase() \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Close the database
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : This method is automatically called within the \fB__del__\fP method, but it is programatically better to call it naturally
.SS Container ISO management

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
Container ISO management features
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Package \fBanwdlserver.tools.iso\fP
.UNINDENT
.UNINDENT
.SS Constants
.sp
Default values :
.TS
center;
|l|l|l|.
_
T{
Name
T}	T{
Value
T}	T{
Description
T}
_
T{
DEFAULT_CONTAINER_ISO_FILE_NAME
T}	T{
“anweddol_container.iso”
T}	T{
The default remote ISO file name
T}
_
T{
DEFAULT_MD5SUM_FILE_NAME
T}	T{
“md5sum.txt”
T}	T{
The default remote ISO MD5 checksum file name
T}
_
T{
DEFAULT_SHA256_FILE_NAME
T}	T{
“sha256sum.txt”
T}	T{
The default remote ISO SHA256 checksum file name
T}
_
T{
DEFAULT_VERSION_FILE_NAME
T}	T{
“version.txt”
T}	T{
The default remote ISO version file name
T}
_
.TE
.SS Classes
.SS \fBRemoteISOManager\fP
.SS Definition
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class RemoteISOManager(permalink_resource_file_url: str = None, container_iso_mirror_url: str = None)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Provides remote container ISO management features
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBpermalink_resource_file_url\fP : The \fI\%permalink resource file\fP URL to use
.IP \(bu 2
\fBcontainer_iso_mirror_url\fP : The container ISO mirror URL to interact with. Must point to the root of the mirror
.UNINDENT
.SS Methods
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getPermalinkResourceFileURL() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the permalink resource file URL
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The instance \fI\%permalink resource file\fP URL
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getContainerISOMirrorURL() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the container ISO mirror URL
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The instance \fI\%container ISO mirror\fP URL
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getPermalinkResourceFileURLContent() \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the remote permalink resource file URL content
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The remote permalink resource file URL content, leading to the actual official container ISO mirror URL (see the technical specifications \fI\%ISO management\fP section for more)
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRemoteISOChecksums() \-> tuple

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the remote ISO MD5 and SHA256 checksums
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
A tuple :
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
(
	iso_md5,
	iso_sha256
)

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBiso_md5\fP : The remote ISO MD5 checksum
.IP \(bu 2
\fBiso_sha256\fP : The remote ISO SHA256 checksum
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
getRemoteISOVersion() \-> int

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Get the remote ISO version
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The remote ISO version, as an integer
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setPermalinkResourceFileURL(permalink_resource_file_url: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the permalink resource file URL content
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBpermalink_resource_file_url\fP : The permalink resource file URL to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setContainerISOMirrorURL(container_iso_mirror_url: str) \-> None 

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Set the container ISO mirror URL
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBcontainer_iso_mirror_url\fP : The container ISO mirror URL to set
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
downloadRemoteISO(output_file: str) \-> None

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Download the remote ISO
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBoutput_file\fP : The output file
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
None
.UNINDENT
.sp
\fBNOTE\fP : When this methods ends, the parameter \fBoutput_file\fP content is stored on the instance for the \fBmakeISOChecksum\fP method

.sp
.ce
----

.ce 0
.sp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
makeISOChecksum(iso_path: str = None) \-> str

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Make the ISO SHA256 checksum
.UNINDENT
.UNINDENT
.sp
\fIParameters\fP :
.INDENT 0.0
.IP \(bu 2
\fBiso_path\fP : The ISO path
.UNINDENT
.sp
\fIReturn value\fP :
.INDENT 0.0
.IP \(bu 2
The SHA256 checksum of the specified ISO
.UNINDENT
.sp
\fBNOTE\fP : If the parameter \fBiso_path\fP is \fBNone\fP, the stored output file from the \fBdownloadRemoteISO\fP method will be used
.SS CLI references
.sp
The actual Anweddol server CLI provides a JSON output feature that allows inter\-program communication.
.SS CLI JSON output

.sp
.ce
----

.ce 0
.sp
.sp
In order to communicate with other programs in an easy way, the Anweddol server CLI provides a JSON output feature that allows [inter\-program communication](https://clig.dev/#simple\-parts\-that\-work\-together.
.SS Global structure
.sp
Each commands with the \fB\-\-json\fP parameter results on a single JSON structure printed on \fBstdout\fP :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: STATUS
	\(dqmessage\(dq: MESSAGE
	\(dqdata\(dq: DATA
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBSTATUS\fP : The result status, it can be \fB\(dqOK\(dq\fP if there was no errors during the process, \fB\(dqERROR\(dq\fP otherwise.
.IP \(bu 2
\fBMESSAGE\fP : The message according to the command purpose.
.IP \(bu 2
\fBDATA\fP : A dictionary containing every exploitable informations that a command can generate.
.UNINDENT
.sp
The \fBDATA\fP dictionary content changes according to the command context (see below).
.sp
\fBNOTE\fP : Configuration file related errors arent produced in a JSON format.
.SS Specific result JSON structures
.SS Errors
.sp
When an error occured during the process with any \fB\-\-json\fP parameter set with subcommands, the output JSON will be :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqERROR\(dq,
	\(dqmessage\(dq: \(dqAn error occured\(dq,
	\(dqdata\(dq: {
		\(dqerror\(dq: ERROR
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBERROR\fP : The error message that occured
.UNINDENT
.SS \fBstart\fP sub\-command
.sp
\fBanwdlserver start\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqServer is started\(dq,
	\(dqdata\(dq: {}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE\fP : If the option \fB\-d\fP is set, no output will be displayed.
.sp
If the option \fB\-c\fP is set :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqCheck done\(dq,
	\(dqdata\(dq: {
		\(dqerrors_recorded\(dq: ERRORS_RECORDED, 
		\(dqerrors_list\(dq: ERRORS_LIST
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If an error occured during server environment verification, the JSON structure looks like this :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqERROR\(dq,
	\(dqmessage\(dq: \(dqErrors detected on server environment\(dq,
	\(dqdata\(dq: {
		\(dqerrors_recorded\(dq: ERRORS_RECORDED, 
		\(dqerrors_list\(dq: ERRORS_LIST
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBERRORS_RECORDED\fP : The amount of errors recorded
.IP \(bu 2
\fBERRORS_LIST\fP : The errors messages list
.UNINDENT
.SS \fBstop\fP sub\-command
.sp
\fBanwdlserver stop\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqServer is stopped\(dq,
	\(dqdata\(dq: {}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBrestart\fP sub\-command
.sp
\fBanwdlserver restart\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqServer is started\(dq,
	\(dqdata\(dq: {}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBdl\-iso\fP sub\-command
.sp
\fBanwdlserver dl\-iso\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqISO image was successfully downloaded\(dq,
	\(dqdata\(dq: {
		\(dqchecksums\(dq: CHECKSUMS,
		\(dqversion\(dq: VERSION,
		\(dqfile_path\(dq: FILE_PATH
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBCHECKSUMS\fP : The downloaded ISO MD5 and SHA256 checksums, in a list
.IP \(bu 2
\fBVERSION\fP : The downloaded \fI\%ISO version\fP
.IP \(bu 2
\fBFILE_PATH\fP : The downloaded ISO file path
.UNINDENT
.sp
if the option \fB\-m\fP is set :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqRemote ISO metadata\(dq,
	\(dqdata\(dq: {
		\(dqchecksums\(dq: CHECKSUMS,
		\(dqversion\(dq: VERSION,
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBCHECKSUMS\fP : The downloaded ISO MD5 and SHA256 checksums, in a list
.IP \(bu 2
\fBVERSION\fP : The downloaded \fI\%ISO version\fP
.UNINDENT
.SS \fBaccess\-tk\fP sub\-command
.sp
\fBanwdlserver access\-tk \-a\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqNew access token created\(dq,
	\(dqdata\(dq: {
		\(dqentry_id\(dq: ENTRY_ID,
		\(dqaccess_token\(dq: ACCESS_TOKEN,
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBENTRY_ID\fP : The created entry ID
.IP \(bu 2
\fBACCESS_TOKEN\fP : The new access token, in plain text
.UNINDENT
.sp
\fBanwdlserver access\-tk \-l\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqRecorded entries ID\(dq,
	\(dqdata\(dq: {
		\(dqentry_list\(dq: ENTRY_LIST
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBENTRY_LIST\fP : The recorded entries list
.UNINDENT
.sp
\fBanwdlserver access\-tk \-r\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqEntry ID was deleted\(dq,
	\(dqdata\(dq: {}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBanwdlserver access\-tk \-e\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqEntry ID was enabled\(dq,
	\(dqdata\(dq: {}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBanwdlserver access\-tk \-d\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqEntry ID was disabled\(dq,
	\(dqdata\(dq: {}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS \fBregen\-rsa\fP sub\-command
.sp
\fBanwdlserver regen\-rsa\fP with the \fB\-\-json\fP parameter will result in :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqstatus\(dq: \(dqOK\(dq,
	\(dqmessage\(dq: \(dqRSA keys re\-generated\(dq,
	\(dqdata\(dq: {
		\(dqfingerprint\(dq: FINGERPRINT
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBFINGERPRINT\fP : The new generated public key’s SHA256 digest
.UNINDENT
.SS Troubleshooting
.sp
A troubleshooting page is also available for the Anweddol server API :
.SS Troubleshooting

.sp
.ce
----

.ce 0
.sp
.sp
Here is a list of non\-exhaustive potential problems that can be encountered while using the Anweddol server API :
.SS \fBlibvirt:  error : Cannot get interface MTU on \(aqvirbr0\(aq\fP[...]
.sp
\fIDescription\fP : The libvirt daemon is not started.
.sp
\fISolution\fP :
.sp
Start the libvirtd daemon :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo systemctl start libvirtd.service

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then restart your script.
.SS Technical specifications

.sp
.ce
----

.ce 0
.sp
.sp
Hello and welcome to the Anweddol server technical specifications.
.sp
You\(aqll retrieve documentation about how the Anweddol server and its affiliated features works.
.SS Core features
.SS Client authentication

.sp
.ce
----

.ce 0
.sp
.sp
Natively, the server handles 2 kinds of credentials :
.INDENT 0.0
.IP \(bu 2
The session credentials ;
.IP \(bu 2
The container credentials ;
.UNINDENT
.SS Session credentials
.sp
The session credentials are credentials used to authenticate a client when a DESTROY request is received.
There is 2 affiliated members :
.INDENT 0.0
.IP \(bu 2
The container UUID ;
.IP \(bu 2
The client token ;
.UNINDENT
.sp
The container UUID is the \fI\%UUID of the container\fP that the client wants to destroy.
.sp
The client token is a private token given to the client when a container is created on receipt of a CREATE request, to ensure that the client who wants to destroy the container in question is actually the one who owns it. A token is a 255\-character url\-safe string, to guarantee minimum usurpability.
.SS Container credentials
.sp
The container credentials are the SSH credentials to use with the container in order to be able to interact with it.
There is 3 affiliated members :
.INDENT 0.0
.IP \(bu 2
The SSH username ;
.IP \(bu 2
The SSH password ;
.IP \(bu 2
The SSH listen port ;
.UNINDENT
.sp
The SSH username is in the format \fBuser_NUM\fP, where NUM is a random number between 10000 and 90000.
.sp
The SSH password is a 120 character string.
.sp
The SSH listen port is a random port between 10000 and 15000, whose bindability is checked before assignation.
.SS Communication

.sp
.ce
----

.ce 0
.sp
.SS Format
.sp
Requests and responses sent between the client and the server are JSON structures.
\-> A widely used data format, cross\-platform and easily manipulable.
.sp
Before sending anything, the size of the packet is sent in an 8 byte message, padded with ‘=’ characters :
.TS
center;
|l|l|l|.
_
T{
Message
T}	T{
Length
T}	T{
Padded message length
T}
_
T{
\fB\(dqhello world\(dq\fP
T}	T{
11 characters
T}	T{
\fB\(dq11======\(dq\fP (8 characters)
T}
_
.TE
.sp
Thus, the native theorical maximum packet size is 99 999 999 bytes.
.SS Request format
.sp
Here is a typical request structure that a server will receive :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqverb\(dq: VERB;
	\(dqparameters\(dq: PARAMETERS
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBVERB\fP : Like an HTTP request, the verb depicts the action to execute on the server side. There is 3 natively supported verbs :
.INDENT 2.0
.IP \(bu 2
\fB\(dqCREATE\(dq\fP : Defines the intent to create a new container.
.IP \(bu 2
\fB\(dqDESTROY\(dq\fP : Defines the intent to destroy a previously created container.
.IP \(bu 2
\fB\(dqSTAT\(dq\fP : Defines the intent to gather information about a server runtime.
.UNINDENT
.IP \(bu 2
\fBPARAMETERS\fP : This is the section reserved for any kind of parameters used to provide additional information in a request.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
Only the \fB\(dqDESTROY\(dq\fP request requires some parameters to authenticate the client (see the \fI\%Authentication\fP section to learn more).
.UNINDENT
.UNINDENT
.SS Response format
.sp
Here is a typical response structure that a client will receive :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqsuccess\(dq: SUCCESS;
	\(dqmessage\(dq: MESSAGE;
	\(dqdata\(dq: DATA
}

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBSUCCESS\fP : The success is a boolean value that defines the current state of the request on the server.
.INDENT 2.0
.IP \(bu 2
\fBTrue\fP : The request was successfully satisfied.
.IP \(bu 2
\fBFalse\fP : There was an error during the processing of the request.
.UNINDENT
.IP \(bu 2
\fBMESSAGE\fP : The additional information coming along with the success of the response.
It can be anything that explains what happened on the server side (see the ‘Error handling’ point below).
.IP \(bu 2
\fBDATA\fP : The data section, reserved for returned parameters.
.UNINDENT
.SS Error handling
.sp
When an error occurs during the processing of a request, a message is set in the response explaining what’s wrong.
.sp
Here is a non\-exhaustive list of status codes and their messages :
.TS
center;
|l|l|.
_
T{
Message
T}	T{
Meaning
T}
_
T{
\fB\(dqOK\(dq\fP
T}	T{
The request was successfully satisfied
T}
_
T{
\fB\(dqBad authentication\(dq\fP
T}	T{
The sender specified invalid credentials
T}
_
T{
\fB\(dqBad request\(dq\fP
T}	T{
The previous request was malformed
T}
_
T{
\fB\(dqRefused request\(dq\fP
T}	T{
The request was refused
T}
_
T{
\fB\(dqUnavailable\(dq\fP
T}	T{
The server is currently unavailable
T}
_
T{
\fB\(dqInternal error\(dq\fP
T}	T{
The server is experiencing an internal error
T}
_
.TE
.sp
Note that messages depicting an error may come with an additional explanation of why the error occurred :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\(dqBad request (reason : Unsupported or unknown verb)\(dq

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Security
.SS Encryption
.sp
For security and integrity reasons, requests and responses are encrypted in AES 256 CBC.
Each AES key and Initialization Vectors are different for every client connection session.
.sp
RSA keys length is 4096 bytes by default. The RSA implementation is used to send the connection session AES key to the client securely.
.sp
Here is a visual example of how the keys are exchanged with a client :
.INDENT 0.0
.INDENT 3.5
Bold text mean RSA encrypted text
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
‘>’/’<’ symbol means ‘send’ and ‘o’ symbol means ‘receive’
.UNINDENT
.UNINDENT
.TS
center;
|l|l|l|.
_
T{
A
T}	T{
packet content
T}	T{
B
T}
_
T{
>
T}	T{
connexion
T}	T{
o
T}
_
T{
>
T}	T{
A RSA public key
T}	T{
o
T}
_
T{
o
T}	T{
validation
T}	T{
<
T}
_
T{
o
T}	T{
B RSA public Key
T}	T{
<
T}
_
T{
>
T}	T{
validation
T}	T{
o
T}
_
T{
>
T}	T{
\fBA AES Key\fP
T}	T{
o
T}
_
T{
o
T}	T{
validation
T}	T{
<
T}
_
T{
o
T}	T{
\fBB AES Key\fP
T}	T{
<
T}
_
T{
>
T}	T{
validation
T}	T{
o
T}
_
.TE
.SS Sanitization
.sp
Requests and responses are sanitized upon sending and receiving at each end.
Here is the raw \fI\%cerberus\fP validation scheme used to verify the format and content :
.sp
\fBRequests\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqverb\(dq: {
		\(dqtype\(dq: \(dqstring\(dq,
		\(dqregex\(dq: r\(dq^[A\-Z]{1,}$\(dq,
		\(dqrequired\(dq: True,
	},
	\(dqparameters\(dq: {
		\(dqtype\(dq: \(dqdict\(dq,
		\(dqrequired\(dq: True,
		\(dqschema\(dq: {
			\(dqcontainer_uuid\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqrequired\(dq: False,
				\(dqcheck_with\(dq: __check_container_uuid,
				\(dqdependencies\(dq: [\(dqclient_token\(dq]
			},
			\(dqclient_token\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqrequired\(dq: False,
				\(dqcheck_with\(dq: __check_client_token,
				\(dqdependencies\(dq: [\(dqcontainer_uuid\(dq]
			}
		}
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBResponses\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
	\(dqsuccess\(dq: {
		\(dqtype\(dq: \(dqboolean\(dq,
		\(dqrequired\(dq: True
	},
	\(dqmessage\(dq: {
		\(dqtype\(dq: \(dqstring\(dq,
		\(dqrequired\(dq: True
	},
	\(dqdata\(dq: {
		\(dqtype\(dq: \(dqdict\(dq,
		\(dqrequired\(dq: True,
		\(dqschema\(dq: {
			\(dqcontainer_uuid\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqregex\(dq: r\(dq^[0\-9a\-f]{8}\-[0\-9a\-f]{4}\-[0\-9a\-f]{4}\-[0\-9a\-f]{4}\-[0\-9a\-f]{12}$\(dq,
				\(dqrequired\(dq: False,
				\(dqdependencies\(dq: [
					\(dqclient_token\(dq,
					\(dqcontainer_iso_sha256\(dq,
					\(dqcontainer_username\(dq,
					\(dqcontainer_password\(dq,
					\(dqcontainer_listen_port\(dq
				]
			},
			\(dqclient_token\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqregex\(dq: r\(dq^[0\-9a\-zA\-Z\-_]{255}$\(dq,
				\(dqrequired\(dq: False,
				\(dqdependencies\(dq: [
					\(dqcontainer_uuid\(dq,
					\(dqcontainer_iso_sha256\(dq,
					\(dqcontainer_username\(dq,
					\(dqcontainer_password\(dq,
					\(dqcontainer_listen_port\(dq
				]
			},
			\(dqcontainer_iso_sha256\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqregex\(dq: r\(dq^[a\-f0\-9]{64}$\(dq,
				\(dqrequired\(dq: False,
				\(dqdependencies\(dq: [
					\(dqcontainer_uuid\(dq,
					\(dqclient_token\(dq,
					\(dqcontainer_username\(dq,
					\(dqcontainer_password\(dq,
					\(dqcontainer_listen_port\(dq
				]
			},
			\(dqcontainer_username\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqregex\(dq: r\(dq^user_[0\-9]{5}$\(dq,
				\(dqrequired\(dq: False,
				\(dqdependencies\(dq: [
					\(dqcontainer_uuid\(dq,
					\(dqclient_token\(dq,
					\(dqcontainer_iso_sha256\(dq,
					\(dqcontainer_password\(dq,
					\(dqcontainer_listen_port\(dq
				]
			},
			\(dqcontainer_password\(dq: {
				\(dqtype\(dq: \(dqstring\(dq,
				\(dqregex\(dq: r\(dq^[a\-zA\-Z0\-9]{1,}$\(dq,
				\(dqrequired\(dq: False,
				\(dqdependencies\(dq: [
					\(dqcontainer_uuid\(dq,
					\(dqclient_token\(dq,
					\(dqcontainer_iso_sha256\(dq,
					\(dqcontainer_username\(dq,
					\(dqcontainer_listen_port\(dq
				]
			},
			\(dqcontainer_listen_port\(dq: {
				\(dqtype\(dq: \(dqinteger\(dq,
				\(dqrequired\(dq: False,
				\(dqmin\(dq: 1,
				\(dqmax\(dq: 65535,
				\(dqdependencies\(dq: [
					\(dqcontainer_uuid\(dq,
					\(dqclient_token\(dq,
					\(dqcontainer_iso_sha256\(dq,
					\(dqcontainer_username\(dq,
					\(dqcontainer_password\(dq
				]
			},
			\(dquptime\(dq: {
				\(dqtype\(dq: \(dqinteger\(dq,
				\(dqrequired\(dq: False,
				\(dqmin\(dq: 0,
				\(dqdependencies\(dq: [\(dqavailable\(dq]
			},
			\(dqavailable\(dq: {
				\(dqtype\(dq: \(dqinteger\(dq,
				\(dqrequired\(dq: False,
				\(dqmin\(dq: 0,
				\(dqdependencies\(dq: [\(dquptime\(dq]
			}
		}
	}
}

.ft P
.fi
.UNINDENT
.UNINDENT
.SS Database

.sp
.ce
----

.ce 0
.sp
.SS Engine
.sp
The server is using a sqlite\-based SQLAlchemy ORM memory database engine to ensure its content volatility.
See the \fI\%SQLAlchemy website\fP to learn more.
.SS Table representation
.sp
Here is a representation of the SQL table used during the server run time :
.TS
center;
|l|l|l|l|.
_
T{
EntryID
T}	T{
CreationTimestamp
T}	T{
ContainerUUID
T}	T{
ClientToken
T}
_
T{
\fBInteger primary key\fP
T}	T{
\fBInteger\fP
T}	T{
\fBString\fP
T}	T{
\fBString\fP
T}
_
.TE
.INDENT 0.0
.IP \(bu 2
\fBEntryID\fP : Store the entry ID
.IP \(bu 2
\fBCreationTimestamp\fP : Store the creation timestamp of the entry
.IP \(bu 2
\fBContainerUUID\fP : Store the container UUID
.IP \(bu 2
\fBClientToken\fP : Store the affiliated client token
.UNINDENT
.SS Security
.sp
The data written in the \fBContainerUUID\fP and the \fBClientToken\fP columns are hashed with SHA256.
.SS Networking

.sp
.ce
----

.ce 0
.sp
.SS Server
.sp
In order to let clients and containers communicate, the server needs a specific interface.
.sp
A bridge interface \fBanwdlbr0\fP must be created on the server, with its current physical network interface configured as a slave on it. Containers will connect via TAP on this bridge, ensuring full\-bridged networking for the container.
.INDENT 0.0
.INDENT 3.5
Read the \(aqAdministration guide\(aq for more info.
.UNINDENT
.UNINDENT
.SS Container
.sp
Each container have two network interfaces :
.INDENT 0.0
.IP \(bu 2
A NAT interface ;
.IP \(bu 2
A bridged interface ;
.UNINDENT
.sp
\-> The NAT interface is used for server administration.It is an interface based on the \fBvirbr0\fP libvirt virtual bridge.
.sp
\-> The bridged interface is used to receive client traffic.
It is based on the manually created bridge on the system (see above), thus providing full\-bridged networking.
.SS Virtualization

.sp
.ce
----

.ce 0
.sp
.SS API
.sp
The Anweddol server uses the Libvirt API to manage containers.
You\(aqll retrieve the full documentation on the \fI\%libvirt python binding\fP documentation website.
.sp
A \fIcontainer\fP is a libvirt domain wrapper utility running with a live debian image (see below).
.sp
The domain XML used for container domain definition is :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<domain type=\(aqkvm\(aq>
	<name>container_uuid</name>
	<memory unit=\(aqMiB\(aq>memory</memory>
	<currentMemory unit=\(aqMiB\(aq>memory</currentMemory>
	<vcpu placement=\(aqstatic\(aq>vcpus/vcpu>
	<uuid>container_uuid</uuid>
	<os>
		<type arch=\(aqx86_64\(aq machine=\(aqpc\(aq>hvm</type>
		<boot dev=\(aqhd\(aq/>
		<boot dev=\(aqcdrom\(aq/>
	</os>
	<features>
		<acpi/>
		<apic/>
		<vmport state=\(aqoff\(aq/>
	</features>
	<clock offset=\(aqutc\(aq>
		<timer name=\(aqrtc\(aq tickpolicy=\(aqcatchup\(aq/>
		<timer name=\(aqpit\(aq tickpolicy=\(aqdelay\(aq/>
		<timer name=\(aqhpet\(aq present=\(aqno\(aq/>
	</clock>
	<pm>
		<suspend\-to\-mem enabled=\(aqyes\(aq/>
		<suspend\-to\-disk enabled=\(aqyes\(aq/>
	</pm>
	<devices>
		<disk type=\(aqfile\(aq device=\(aqcdrom\(aq>
			<driver name=\(aqqemu\(aq type=\(aqraw\(aq/>
			<source file=\(aqiso_path\(aq/>
			<target dev=\(aqhda\(aq bus=\(aqide\(aq/>
			<address type=\(aqdrive\(aq controller=\(aq0\(aq bus=\(aq0\(aq target=\(aq0\(aq unit=\(aq0\(aq/>
		</disk>
		<interface type=\(aqbridge\(aq>
	        <start mode=\(aqonboot\(aq/>
	        <source bridge=\(aqnat_interface_name\(aq/> 
	        <model type=\(aqvirtio\(aq/>
	    </interface>
        <interface type=\(aqbridge\(aq>
            <start mode=\(aqonboot\(aq/>
            <source bridge=\(aqbridge_interface_name\(aq/>
            <model type=\(aqvirtio\(aq/>
        </interface>
        <memballoon model=\(aqvirtio\(aq>
			<address type=\(aqpci\(aq domain=\(aq0x0000\(aq bus=\(aq0x00\(aq slot=\(aq0x07\(aq function=\(aq0x0\(aq/>
		</memballoon>
	</devices>
</domain>

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBcontainer_uuid\fP : The container UUID
.IP \(bu 2
\fBmemory\fP : The container domain memory amount
.IP \(bu 2
\fBvcpus\fP : The container domain virtual CPUs amount
.IP \(bu 2
\fBiso_path\fP : The ISO file path that will be used by the container domain
.IP \(bu 2
\fBnat_interface_name\fP : The NAT interface name that will be used by the container domain
.IP \(bu 2
\fBbridge_interface_name\fP : The bridge interface name that will be used by the container domain
.UNINDENT
.SS Container OS
.sp
The operating system running on containers is a custom live Debian to ensure as little data remanence as possible on the virtual domain.
.sp
All basic tools like text editors, network interactions, development environment are already pre\-installed to bring comfortable usage for the client.
.INDENT 0.0
.INDENT 3.5
This ISO image is meant to be replaced at each update announced. You can download it on the actual \fI\%permalink officlal mirror\fP or via the server CLI (See the \fI\%Administration guide\fP to learn more).
.UNINDENT
.UNINDENT
.SS Management
.sp
During a server runtime, running container coordinates created for clients are stored in memory to manage them.
.sp
If a container is shut down, a routine will detect that its domain is not active, and will delete the container\(aqs presence in memory and database to prevent ghosted credentials.
.sp
Containers are identified with an UUID4 format string, and their \fI\%libvirt domains UUID\fP are the same one.
.SS Administration
.sp
When a container is started, the server first waits for the network to be available inside.
Then, the server generates new user coordinates and a new listen port that the container will use for client service.
.sp
On every container a specific user is defined called \fBendpoint\fP\&.
.sp
This is a user dedicated to container administration that the server will interact via SSH to administrate it (it is actually calling a bash script inside that you can retrieve on the ISO factory \fI\%github repository\fP). Its default password is \fBendpoint\fP, and the container default SSH server is listening on the conventional port (80).
.sp
The bash script executes 3 tasks :
.INDENT 0.0
.IP \(bu 2
Create the new specified user that the client will use ;
.IP \(bu 2
Set up the new SSH listen port ;
.IP \(bu 2
Disabling the endpoint user once its task is executed ;
.UNINDENT
.sp
The username is in the format \fBuser_NUM\fP, where NUM is a random number between 10000 and 90000.
The user password is a 120 character string.
The new listen port is a random port between 10000 and 15000, whose bindability is checked before assignation.
.sp
When the script will be called, the container will only accept SSH connections with the newly created user, since the endpoint user will be disabled in the process.
.SS Tools features
.SS Access token

.sp
.ce
----

.ce 0
.sp
.sp
An access token system is provided in the \fBtools\fP features.
It is used to restrict users of the service by providing tokens to authenticate them before processing the request.
.sp
A typical use case is when a client sends a request on a server, it must send an access token in the request parameters that must match one of the tokens in the database in order to be processed by the server.
.SS Tokens
.sp
Tokens used are 124 characters url\-safe strings.
.SS Database
.SS Engine
.sp
This feature is using a SQLite file to store data.
.SS Table representation
.sp
Here is a representation of the used SQL table :
.TS
center;
|l|l|l|l|.
_
T{
EntryID
T}	T{
CreationTimestamp
T}	T{
AccessToken
T}	T{
Enabled
T}
_
T{
\fBINTEGER NOT NULL PRIMARY KEY\fP
T}	T{
\fBINTEGER NOT NULL\fP
T}	T{
\fBTEXT NOT NULL\fP
T}	T{
\fBINTEGER NOT NULL\fP
T}
_
.TE
.INDENT 0.0
.IP \(bu 2
\fBEntryID\fP : Identifies the row
.IP \(bu 2
\fBCreationTimestamp\fP : Store the row creation timestamp
.IP \(bu 2
\fBAccessToken\fP : Store the affiliated access token
.IP \(bu 2
\fBEnabled\fP : Store a boolean value (\fB1\fP / \fB0\fP) depicting if the row must be used or ignored
.UNINDENT
.SS Security
.sp
Any tokens written in the \fBAccessToken\fP column are hashed with SHA256.
.SS ISO management

.sp
.ce
----

.ce 0
.sp
.sp
In order to provice a valid service, containers domains needs to run with a specific ISO image.
.sp
This ISO image is actually a custom live Debian image, with pre\-installed utility softwares (text editors, programming environment, network tools, …) for the user.
See the \fI\%ISO factory repository\fP to get the script that creates these ISO images.
.SS Official mirror
.sp
Containers ISO images are actually provided via a mirror URL that you can retrieve on the official website \fI\%permalink resource file\fP\&.
.sp
This resource file contains a container ISO mirror URL with this file tree :
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.
├── anweddol_container.iso
├── md5sum.txt
├── sha256sum.txt
└── version.txt

.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBanweddol_container.iso\fP is the actual container ISO image.
.IP \(bu 2
\fBmd5sum.txt\fP contains the MD5 checksum of \fBanweddol_container.iso\fP
.IP \(bu 2
\fBsha256sum.txt\fP contains the SHA256 checksum of \fBanweddol_container.iso\fP
.IP \(bu 2
\fBversion.txt\fP is the version of the ISO. It contains an integer  which is incremented by 1 each updates.
.UNINDENT
.sp
\fBNOTE\fP : Always use the container ISO mirror URL specified in the permalink resource file, since it can be modified at any moment.
.SH CONTRIBUTION
.sp
See the contribution section to know how to contribute :
.SS Contribute

.sp
.ce
----

.ce 0
.sp
.sp
Thank you for taking the time to contribute to the Anweddol project!
.sp
In this guide you will retrieve the contribution guidelines.
.SS Getting started
.sp
In order to be able to bring new ideas and enhancements with ease, you can read the \fITechnical specifications\fP of the Anweddol server to know how it works.
.SS Issues
.SS Create an issue
.sp
If you encounter a problem with the software, be it a bug or a potential error in the code or the docs, search for another issue of its kind first to prevent duplicates. If you find one, you can comment on it to give more importance to the issue.
.SS Solve / contribute to an issue
.sp
You can scroll through the issues and find one that interests you. There is no assignee for issues : Everyone is free to contribute to it.
.SS Make changes
.SS Pull requests
.sp
Any changes will result in a new pull request, which will be reviewed before merging.
.SS Documentation
.sp
If your modification proposition involves a modification of the core features or of an already documented one, you need to provide the appropriate documentation as well.
.SH LINKS
.sp
Here is the social links of the Anweddol project :
.INDENT 0.0
.IP \(bu 2
\fI\%https://www.reddit.com/r/Anweddol/\fP
.IP \(bu 2
\fI\%https://github.com/the\-anweddol\-project\fP
.IP \(bu 2
\fI\%https://anweddol.zulipchat.com\fP
.UNINDENT
.sp
You can also mail \fBthe\-anweddol\-project@proton.me\fP, consider using the \fI\%PGP public key\fP
.SH INDICES AND TABLES
.INDENT 0.0
.IP \(bu 2
\fI\%Index\fP
.IP \(bu 2
\fI\%Search Page\fP
.UNINDENT
.SH AUTHOR
The Anweddol project
.SH COPYRIGHT
2023, The Anweddol project
.\" Generated by docutils manpage writer.
.
